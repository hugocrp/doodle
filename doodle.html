<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle Jump</title>
</head>
<body>
    <p>Score =
        <span id="score">0</span>
        <button id="play" onclick="play()">Jouer</button>
    </p>

    <div style="display: flex; align-items: center; justify-content: center; height: 100vh;">
        <canvas id="my_canvas" width="210" height="410" style="border: 1px solid red"></canvas>
    </div>

    <script>
        // Base class for game objects
        class GameObject {
            constructor(posX, posY, width, height) {
                this.position = { x: posX, y: posY };
                this.width = width;
                this.height = height;
            }
        }

        // Platform class with movement logic for blue platforms
        class Platform extends GameObject {
            constructor(posX, posY, width, height, color) {
                super(posX, posY, width, height);
                this.color = color;
                this.direction = color === 'blue' ? 1 : 0;
            }

            update() {
                if (this.color === 'blue') {
                    this.position.x += this.direction;
                    if (this.position.x <= 0 || this.position.x + this.width >= 210) {
                        this.direction *= -1;
                    }
                }
            }
        }

        // Player class
        class Player extends GameObject {}

        // Model class containing game logic
        class Model {
            static GRAVITY = 20;
            static JUMP_FORCE = 600;
            static SPEED = 200;
            static PLATFORM_WIDTH = 50;
            static PLATFORM_HEIGHT = 10;
            static PLATFORM_COUNT = 100;

            constructor() {
                this.isGameOver = false;
                this.score = 0;
                this.direction = 0;
                this.gravitySpeed = 0;
                this.player = new Player(100, 200, 50, 50);
                this.platforms = this.generatePlatforms();
            }

            bindDisplay(callback) {
                this.displayCallback = callback;
            }

            move(fps) {
                this.gravitySpeed += Model.GRAVITY;
                this.player.position.y += this.gravitySpeed / fps;
                this.player.position.x += this.direction * Model.SPEED / fps;

                if (this.player.position.y > 400) {
                    this.jump();
                }

                if (this.player.position.x > 200) {
                    this.player.position.x = 0;
                } else if (this.player.position.x < 0) {
                    this.player.position.x = 200;
                }
                
                this._generateNewPlatforms();   
                this.updatePlatforms();
                this.sliding();
                this.checkPlatformCollision();
                this.checkDeath();
                this.displayCallback(this.player, this.platforms);
            }

            jump() {
                this.gravitySpeed = -Model.JUMP_FORCE;
            }

            generatePlatforms() {
                const platforms = [];
                for (let i = 0; i < 10; i++) {
                    const posX = Math.random() * (210 - Model.PLATFORM_WIDTH);
                    const posY = i * (400 / 10);
                    const color = Math.random() < 0.5 ? 'green' : 'blue';
                    platforms.push(new Platform(posX, posY, Model.PLATFORM_WIDTH, Model.PLATFORM_HEIGHT, color));
                }
                return platforms;
            }

            updatePlatforms() {
                this.platforms.forEach(platform => platform.update());
            }

            _generateNewPlatforms() {
                const highestPlatform = this.platforms.reduce((max, platform) => 
                    platform.position.y < max.position.y ? platform : max, 
                    this.platforms[0]
                );

                if (highestPlatform.position.y > 100) {
                    let color = Math.random() < 0.5 ? 'green' : Math.random() < 0.5 ? 'blue' : 'gray';
                    let posX = Math.random() * (210 - Model.PLATFORM_WIDTH);
                    let posY = highestPlatform.position.y - 100;
                    this.platforms.push(new Platform(posX, posY, Model.PLATFORM_WIDTH, Model.PLATFORM_HEIGHT, color));
                }
            }

            checkPlatformCollision() {
                this.platforms.forEach(platform => {
                    if (
                        this.player.position.x < platform.position.x + platform.width &&
                        this.player.position.x + this.player.width > platform.position.x &&
                        this.player.position.y + this.player.height > platform.position.y &&
                        this.player.position.y + this.player.height < platform.position.y + platform.height &&
                        this.gravitySpeed > 0
                    ) {
                        this.jump();
                        if (platform.color === 'gray') {
                            this.platforms = this.platforms.filter(p => p !== platform);
                        }
                    }
                });
            }

            checkDeath() {
                if (this.player.position.y > 400) {
                    this.isGameOver = true;
                    this.resetGame();
                }
            }

            resetGame() {
                this.player.position = { x: 100, y: 200 };
                this.score = 0;
                this.platforms = this.generatePlatforms();
                document.getElementById('score').innerText = this.score;
            }

            sliding() {
                if (this.player.position.y < 200) {
                    const sliding = 200 - this.player.position.y;
                    this.score += sliding;
                    document.getElementById('score').innerText = this.score;
                    this.player.position.y = 200;
                    this.platforms.forEach(platform => (platform.position.y += sliding));
                }
            }

            setDirection(value) {
                this.direction = value;
            }
        }

        // View class for rendering the game
        class View {
            constructor() {
                this.canvas = document.getElementById('my_canvas');
                this.ctx = this.canvas.getContext('2d');
                this.holdRight = false;
                this.holdLeft = false;
                this._lastDirection = 0;

                this.characterImage = new Image();
                this.characterImage.src = 'assets/img/character.png';

                this.backgroundImage = new Image();
                this.backgroundImage.src = 'assets/img/background.png';

                this.bindEvents();
            }

            bindSetDirection(callback) {
                this.setDirectionCallback = callback;
            }

            display(player, platforms) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.drawImage(this.backgroundImage, 0, 0, this.canvas.width, this.canvas.height);

                platforms.forEach(platform => {
                    this.ctx.fillStyle = platform.color;
                    this.ctx.fillRect(platform.position.x, platform.position.y, platform.width, platform.height);
                });

                this.ctx.save();
                
                if (this._lastDirection === -1) {
                    this.ctx.scale(-1, 1);
                    this.ctx.drawImage(
                        this.characterImage,
                        -player.position.x - player.width, 
                        player.position.y, 
                        player.width, 
                        player.height
                    );
                } else {
                    this.ctx.drawImage(
                        this.characterImage,
                        player.position.x,
                        player.position.y,
                        player.width,
                        player.height
                    );
                }

                this.ctx.restore();
            }

            bindEvents() {
                document.addEventListener('keydown', evt => {
                    if (evt.key === 'ArrowLeft' || evt.key === 'ArrowRight') {
                        if (evt.key === 'ArrowLeft') {
                            this._lastDirection = -1;
                            this.holdLeft = true;
                            if (this.setDirectionCallback) this.setDirectionCallback(-1);
                        } else if (evt.key === 'ArrowRight') {
                            this._lastDirection = 1;
                            this.holdRight = true;
                            if (this.setDirectionCallback) this.setDirectionCallback(1);
                        }
                    }
                });

                document.addEventListener('keyup', evt => {
                    if (evt.key === 'ArrowLeft' || evt.key === 'ArrowRight') {
                        if (evt.key === 'ArrowLeft') {
                            this.holdLeft = false;
                            if (!this.holdRight && this.setDirectionCallback) this.setDirectionCallback(0);
                        } else if (evt.key === 'ArrowRight') {
                            this.holdRight = false;
                            if (!this.holdLeft && this.setDirectionCallback) this.setDirectionCallback(0);
                        }
                    }
                });
            }
        }

        // Controller class to link model and view
        class Controller {
            constructor(model, view) {
                this.model = model;
                this.view = view;
                this.model.bindDisplay(this.view.display.bind(this.view));
                this.view.bindSetDirection(this.model.setDirection.bind(this.model));
            }

            update(fps) {
                this.model.move(fps);
            }
        }

        const model = new Model();
        const view = new View();
        const controller = new Controller(model, view);

        function gameLoop() {
            if (!model.isGameOver) {
                controller.update(60);
                requestAnimationFrame(gameLoop);
            }
        }

        function play() {
            model.resetGame();
            model.isGameOver = false;
            gameLoop();
        }
    </script>
</body>
</html>
