<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle Jump</title>
</head>
<body>
    <div style="display: flex; align-items: center; justify-content: center; height: 100vh;">
        <canvas id="my_canvas" width="210" height="410" style="border: 1px solid red"></canvas>
    </div>

    <script>
        class GameObject {
            constructor(posX, posY, weight, height) {
                this._position = {x: posX, y: posY};
                this._weight = weight;
                this._height = height;
            }

            get position() { return this._position; }
            set position(value) { this._position = value; }

            get weight() { return this._weight; }
            set weight(value) { this._weight = value; }

            get height() { return this._height; }
            set height(value) { this._height = value; }
        }

        class Platform extends GameObject {
            constructor(posX, posY, weight, height, color) {
                super(posX, posY, weight, height);
                this._color = color;
            }

            get color() { return this._color; }
            set color(value) { this._color = value; }
        }

        class Model {
            static GRAVITY    = 20;
            static JUMP_FORCE = 600;
            static SPEED      = 200;
            static PLATFORM_WIDTH = 50;
            static PLATFORM_HEIGHT = 10;
            static PLATFORM_COUNT = 10;
            static SLIDING_LIMIT = 350;

            constructor() {
                this._direction = 0;                
                this._gravitySpeed = 0;
                this._position = {x: 100, y:200};
                this._platforms = this._generatePlatforms();
            }

            get position() { return this._position; }

            get direction() { return this._direction; }
            set direction(value) { this._direction = value; }
            
            BindDisplay(callback) {
                this.b_Display = callback;
            }

            Move(fps) {
                this._gravitySpeed += Model.GRAVITY;
                this._position.y += this._gravitySpeed / fps;
                this._position.x += this._direction * Model.SPEED / fps;

                if (this._position.y > 400) {
                    this._Jump();
                }

                this._sliding();
                this._checkPlatformCollision();
                this._generateNewPlatforms();
                this.b_Display(this._position, this._platforms);
            }

            _Jump() {
                this._gravitySpeed = -Model.JUMP_FORCE;
            }

            _generatePlatforms() {
                let platforms = [];
                for (let i = 0; i < Model.PLATFORM_COUNT; i++) {
                    let posX = Math.random() * (210 - Model.PLATFORM_WIDTH);
                    let posY = i * 100;
                    platforms.push(new Platform(posX, posY, Model.PLATFORM_WIDTH, Model.PLATFORM_HEIGHT, 'green'));
                }
                return platforms;
            }

            _generateNewPlatforms() {
                const highestPlatform = this._platforms.reduce((max, platform) => platform.position.y < max.position.y ? platform : max, this._platforms[0]);
                if (highestPlatform.position.y > 100) {
                    let posX = Math.random() * (210 - Model.PLATFORM_WIDTH);
                    let posY = highestPlatform.position.y - 100;
                    this._platforms.push(new Platform(posX, posY, Model.PLATFORM_WIDTH, Model.PLATFORM_HEIGHT, 'green'));
                }
            }

            _checkPlatformCollision() {
                for (let platform of this._platforms) {
                    if (this._position.x < platform.position.x + platform.weight &&
                        this._position.x + 10 > platform.position.x &&
                        this._position.y < platform.position.y + platform.height &&
                        this._position.y + 10 > platform.position.y &&
                        this._gravitySpeed > 0) {
                        this._Jump();
                    }
                }
            }

            _sliding() {
                if (this._position.y < 200) {
                    let sliding = 200 - this._position.y;
                    this._position.y = 200;
                    for (let platform of this._platforms) {
                        platform.position.y += sliding;
                    }
                }
            }

            setDirection(value) {
                this._direction = value;
            }
        }

        class View {
            constructor() {
                this._canvas = document.getElementById('my_canvas');
                this.ctx     = this._canvas.getContext('2d');
                this._hold_right = false;
                this._hold_left = false;

                this.Events();
            }

            BindSetDirection(callback) {
                this.b_SetDirection = callback;
            }

            Display(position, platforms) {
                let x = position.x;
                let y = position.y;
                
                this.ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
                
                // Dessiner une ligne horizental de gauche à droite où y = 50% de la hauteur du canvas
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0.5 * this._canvas.height);
                this.ctx.lineTo(this._canvas.width, 0.5 * this._canvas.height);
                this.ctx.stroke();


                // Dessiner les plateformes
                for (let platform of platforms) {
                    this.ctx.fillStyle = platform.color;
                    this.ctx.fillRect(platform.position.x, platform.position.y, platform.weight, platform.height);
                }

                // Dessiner le doodle
                this.ctx.fillStyle = 'blue';
                this.ctx.fillRect(x, y, 10, 10);
            }

            Events() {
                document.addEventListener('keydown', (evt) => {                
                    if (evt.key == 'ArrowLeft' || evt.key == 'ArrowRight') {
                        switch (evt.key) {
                            case 'ArrowLeft': // Move left.
                                this._hold_left = true;
                                this.b_SetDirection(-1);
                                break;
                            case 'ArrowRight': // Move right.
                                this._hold_right = true;
                                this.b_SetDirection(1);
                                break;
                        }
                    }
                });

                document.addEventListener('keyup', (evt) => {
                    if (evt.key == 'ArrowLeft' || evt.key == 'ArrowRight') {
                        switch (evt.key) {
                            case 'ArrowLeft': // Stop moving left.
                                this._hold_left = false;
                                if (!this._hold_right) this.b_SetDirection(0);
                                break;
                            case 'ArrowRight': // Stop moving right.
                                this._hold_right = false;
                                if (!this._hold_left) this.b_SetDirection(0);
                                break;
                        }
                    }
                });
            }
        }

        class Controller {
            constructor(model, view) {
                this.model = model;
                this.view = view;
                this.model.BindDisplay(this.view.Display.bind(this.view));
                this.view.BindSetDirection(this.model.setDirection.bind(this.model));
            }

            Update(fps) {
                this.model.Move(fps);
            }
        }

        // Initialisation
        const canvas = document.getElementById('my_canvas');
        const model = new Model();
        const view = new View();
        const controller = new Controller(model, view);

        function gameLoop() {
            controller.Update(60);
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>